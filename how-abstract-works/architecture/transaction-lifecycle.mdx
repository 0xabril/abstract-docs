---
title: "Transaction Lifecycle"
description: "Learn how transactions are processed on Abstract and finalized on Ethereum."
---

As explained in the [layer 2s](/how-abstract-works/architecture/layer-2s)
section, Abstract inherits the security properties of Ethereum by posting
batches of L2 transactions to the L1 and using ZK proofs to ensure their correctness.

This interaction between L2 and L1 is managed by a set of smart contracts to
transfer batches of transactions, enforce [data availability](https://ethereum.org/en/developers/docs/data-availability/),
and ensure the validity of the ZK proofs.

This flow can be broken down into four phases, which are visible for each transaction
on our [block explorers](/ecosystem/block-explorers):


<Steps>
  <Step title="Abstract (Processed)">
    Abstract (Processed): The transaction is executed and soft confirmation is 
    provided back to the user about the execution of their transaction (i.e. if their transaction succeeded or not). 

    After execution, the sequencer both forwards the block to the prover and creates a 
    batch containing transactions from multiple blocks. [Example batch 竊余(https://explorer.testnet.abs.xyz/batch/3678).
    </Step>
    
    <Step title="Ethereum (sending)">
    Multiple batches are committed to the Ethereum blockchain in a single transaction
    in the form of an optimized data submission that only details the changes 
    in blockchain state; called a 
    **<Tooltip tip="State diffs offer a more cost-effective approach to transactions than full 
    transaction data. By omitting signatures and publishing only the final state when multiple 
    transactions alter the same slots.">state diff</Tooltip>**.

    This is achieved by calling the `commitBatches` function on the L1 smart contract. 
    [Example transaction 竊余(https://sepolia.etherscan.io/tx/0xe6b786435793f9d66f907dd6c28eac709463e83e617a10f9afc64749719b85e5).
    The batches are stored on L1 using [blobs](https://info.etherscan.com/what-is-a-blob/) following the [EIP-4844](https://www.eip4844.com/) standard.
  </Step>
  
  <Step title="Ethereum (validating)">
    A ZK proof that validates the batches is generated and submitted to the Ethereum smart contract for verification by calling the
    `verifyBatches` function on the L1 smart contract. [Example transaction 竊余(https://sepolia.etherscan.io/tx/0x3a30e04284fa52c002e6d7ff3b61e6d3b09d4c56c740162140687edb6405e38c).
  </Step>
  
  <Step title="Ethereum (executing)">
    Finalize the state and save Merkle tree with L2 logs shortly 
    after validation by calling the `executeBatches` function on the L1 smart contract.
    [Example transaction 竊余(https://sepolia.etherscan.io/tx/0x16891b5227e7ee040aab79e2b8d74289ea6b9b65c83680d533f03508758576e6).
  </Step>
</Steps>